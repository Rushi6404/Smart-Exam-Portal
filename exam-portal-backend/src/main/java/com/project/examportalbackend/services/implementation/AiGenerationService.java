package com.project.examportalbackend.services.implementation;

import com.project.examportalbackend.models.Question;
import com.project.examportalbackend.models.Quiz;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Service
public class AiGenerationService {

        @Value("${gemini.api.key}")
        private String apiKey;

        @Value("${gemini.api.url}")
        private String apiUrl;

        @Autowired
        private RestTemplate restTemplate;

        /**
         * Generates questions using Google Gemini AI.
         * The hardcoded question poll has been removed as per user request.
         */
        public List<Question> generateQuestions(String topic, int totalQuestions, String difficulty, Quiz quiz) {
                try {
                        System.out.println("DEBUG: Starting AI-only generation for topic: " + topic);
                        System.out.println("DEBUG: Difficulty: " + difficulty + ", Count: " + totalQuestions);

                        return generateQuestionsWithGemini(topic, totalQuestions, difficulty, quiz);
                } catch (Exception e) {
                        System.err.println("DEBUG: AI Generation failed: " + e.getMessage());
                        e.printStackTrace();
                        throw new RuntimeException(
                                        "AI Question Generation failed. Please check your API key and connection: "
                                                        + e.getMessage());
                }
        }

        private List<Question> generateQuestionsWithGemini(String topic, int count, String difficulty, Quiz quiz)
                        throws Exception {
                String prompt = String.format(
                                "Generate %d multiple-choice questions for the topic '%s' with difficulty level '%s'. "
                                                +
                                                "Format the response ONLY as a JSON array of objects with these exact fields: "
                                                +
                                                "content, option1, option2, option3, option4, answer (the value must be one of 'option1', 'option2', 'option3', or 'option4'). "
                                                +
                                                "Do not include any other text or markdown formatting except the JSON array.",
                                count, topic, difficulty);

                Map<String, Object> requestBody = Map.of(
                                "contents", List.of(
                                                Map.of("parts", List.of(
                                                                Map.of("text", prompt)))));

                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);

                String url = apiUrl + "?key=" + apiKey;

                ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);
                System.out.println("DEBUG: Gemini API Response Status: " + response.getStatusCode());

                if (response.getStatusCode() == HttpStatus.OK) {
                        ObjectMapper mapper = new ObjectMapper();
                        JsonNode root = mapper.readTree(response.getBody());

                        if (root.path("candidates").isMissingNode() || root.path("candidates").isEmpty()) {
                                throw new RuntimeException("No response generated by Gemini AI.");
                        }

                        String text = root.path("candidates").get(0).path("content").path("parts").get(0).path("text")
                                        .asText();

                        // Clean up potential markdown formatting
                        text = text.trim();
                        if (text.startsWith("```json")) {
                                text = text.substring(7);
                        } else if (text.startsWith("```")) {
                                text = text.substring(3);
                        }
                        if (text.endsWith("```")) {
                                text = text.substring(0, text.length() - 3);
                        }
                        text = text.trim();

                        JsonNode questionsArray = mapper.readTree(text);
                        List<Question> questions = new ArrayList<>();
                        for (JsonNode node : questionsArray) {
                                Question q = new Question();
                                q.setContent(node.path("content").asText());
                                q.setOption1(node.path("option1").asText());
                                q.setOption2(node.path("option2").asText());
                                q.setOption3(node.path("option3").asText());
                                q.setOption4(node.path("option4").asText());
                                q.setAnswer(node.path("answer").asText());
                                q.setQuiz(quiz);
                                questions.add(q);
                        }
                        return questions;
                }
                throw new RuntimeException("Failed to get response from Gemini: " + response.getStatusCode());
        }
}
